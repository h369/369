引言
ssl/tls协议是应用范围非常广泛的密码协议之一。
目的是：为网络中通信的双方建立一个安全的通信信道。
信道需要通信双方提供认证、机密性和完整性。实际应用种最复杂的密码协议之一。高度的复杂性，版本众多，扩展、变体、工作模式、参数算法协商复杂多变。
复杂性，版本更新缓慢导致设计和实现过程存在许多漏洞
保护数据安全的特殊性使得协议存在很大的攻击价值。
攻击方式包括：8种
降级攻击、重协商攻击、lucky Thirteen攻击、POODLE攻击、BEAST攻击、Heartbleed攻击、时间查分攻击、因代码实现问题产生的攻击、etc

二
协议简介：
ssl源于Netscape，3.0于1996年发布，对后续TLS的发展有着基本的指导作用。也确定了协议目标，整体的层次结构（主要由记录协议和握手协议组成）目前的最高版本为TLS1.2，版本陈旧，存在许多的漏洞，互联网工程任务组开始筹划制定新的版本TLS1.3
1.1  SSL3.0-TLS1.3发展历程
SSL是Netscape开发的专门用户保护Web通讯的，目前版本为3.0。最新版本的TLS 1.0是IETF(工程任务组)制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的。
ＲFC ( Ｒequest For Comments) 文档是由互联网工程任务组发布的一系列备忘录，是用以记录互联网规范、协议及过程等的标准。
文件。
1.2  TLS1.3协议结构
包括三部分：握手协议、警告协议、记录协议
如图 1 灰色方框所示。其在 TCP /IP 协议中介于应用层协议和可靠的传输层协议之间， 且独立于应用层协议， 因此可以置于很多不同的协议之下， 如-HTTP、FTP、SMTP、XMTP 等
当客户端和服务器端双方第一次建立连接时可通过握手协议协商协议版本，选择密码算法，认证通信双方，协商算法所需参数， 且能防篡改。握手协议完成后，记录协议用握手协议协商好的算法和参数对消息流进行分块加密。

1.2.1 握手协议三个阶段
* 密钥交换：选择协议版本和密码算法，协商所需参数，明文传输
* 服务器参数：建立其他的握手协议参数，如是否需要认证客户端，消息由握手层密钥加密传输。
* 认证：认证通信双方（客户端认证可选）保证握手消息的完整性，消息由握手层流密钥加密后传输。
   三个阶段完成后，课进行应用层数据的传输，应用层数据由流密钥（traffic secret）加密后传输
1.2.2 记录协议
记录协议位于握手协议下层， 发送方从高层接受任意长度的非空数据，对其进行合并或分块处理， 然后利用带有辅助数据的认证加密 AEAD ( authenticated encryption with associated data) 进行加密传输。接收方接收数据后对其进行解密和验证， 重组后再传送给高层用户。
两步处理：
分片:
 把上层数据分片或合并成易于处理的数据分组，大小不超过 214字节。记录协议的数据类型有三种: 握手消息， 应用数据， 警告消息。警告消息的级别有两种: 一种是预警错误，用来指示连接的正常有序关闭或者 0-ＲTT 早期数据发送结束， 对通信过程没有影响; 一种是致命错误， 用来指示连接的非正常关闭， 收到这类警告消息后通信双方应立即中断会话， 不再收发消息。注意: 对记录层消息进行分片处理时不能对警告消息进行分块处理。此外， 握手消息和警告消息的消息长度不能为 0， 应用数据的消息长度可以为 0，用来防范针对流量分析的攻击。
载荷保护: 将明文数据通过 AEAD 认证加密算法加密为密文， 密文数据的长度略大于明文数据长度。明文数据结构由消息片段， 数据类型和任意长度的填充 0 值这三个部分组成， 作为 AEAD 的一个输入值计算得到加密内容。TLS 密文数据结构包括四个部分:数据类型、协议版本、消息长度和加密内容。其中数据类型字段一直都被设置为应用数据， 真实的数据类型
可以从明文的数据类型获取， 该字段是为了兼容之前版本而存在。协议版本与明文消息的协议版本功能一模一样，一直被设置为 0x0301( TLS1． 0) ， 真实的协议版本可以从客户端和服务器端的 Hello 消息获取。因此，TLS 密文中的数据类型和协议版本这两个字段在后续版本中可能会被除去。
0 值填充主要是为发送方隐藏真实数据长度而设计。接收方解密密文后，从后往前读取数据， 直到遇到非 0 的值，即明文的数据类型这一字段。
三  TLS1.3主要改变
2.1 握手层信息结构的改变
从之前的四步交互简化为三步
移除：改变密码规范，密钥交换消息
新增：为通信双方新增了几个Hello扩展消息；新增“请求重新握手消息”
“握手完成”消息对握手层的所有消息进行哈希，进一步保证消息的完整性。
2.2 算法的移除与更新
计算机的软硬件各方面性能都得到了极大的提升，计算速度以惊人的速度在增长，攻击方法也一直在涌现。
移除算法：DH、RC4、记录层压缩算法、重协商、椭圆曲线算法，以及哈希算法（如MD5、SHA_1、SHA_224等）
引进算法：AEAD、RFC4492种引入CFRG曲线和签名算法
2.3  密钥生成表
TLS 握手协议协商生成一个或多个密钥， 如图 4所示，以这些密钥作为输入通过哈希密钥推导提取函数和哈希密钥推导扩展函数推导出多个记录层所需的密钥。哈希密钥推导提取函数按照箭头方向从上接收参数做加盐操作， 从右边接收因特网密钥管理参数。密钥扩展函数有三个输入值: 密钥、标签和握手消息。按照图 4 箭头方向所示从上端接收参数作为第一个密钥参数。
由于不同的密码方案存在不同的安全性限制， 需要为不同的密码算法设置各自的密钥更新时间限度。可结合握手层的“密钥更新”消息告知通信双方及时更新密钥。
如果使用 PSK 模式， 客户端必须发送“预共享密钥模式”( 见 2． 4． 2) 消息。预共享密钥交互模式有两种: ( EC) DHE-PSK 和纯 PSK 模式。前一种模式在减少数据传输时延的同时还可以保证前向安全， 而后一种模式则不能保证。
2.4 PSK
目的：简化频繁通信的双方握手协议的认证过程。
如图 5 所示， 共享有效“会话票据”( 见 2． 4． 1) 的通信双方不用发送“证书”和“证书认证”消息。第一次握手时， 客户端和服务器端建立通信，共享会话票据。连接断开后，客户端再次与服务器建立通信时可以通过 PSK 进行认证， 只有真实的通信双方才能解密会话票据得到票据， 知道相应的会话恢复密钥， 后续才能导出加密应用数据的流密钥。如图 6 所示，后续握手阶段， 客户端通过“预共享密钥模式”消息告诉服务器其选择的密钥交换模式，通过“预共享密钥”告知服务器 PSK IDs， 这两个消息必须发送。客户端可以选择给服务器发送“密钥共享”消息， 让服务器选择是否接受会话恢复， 若不接受，可回退进行完整的握手协议
2.4.1 会话票据
在服务器给客户端发送“握手完成”消息以后的任意时间里，服务器都可以给客户端发送“会话票据”消息( 如图 5 灰色方框) 。会话票据绑定了票据和会话恢复密钥。会话票据( 图 7) 消息包含 4 个字段。后续握手协议中，客户端可以在“预共享密钥”消息中将密钥名字( 也即 PSK ID) 发送给服务器。客户端不能重复使用一个票据多次，且优先使用最新的票据。
  为了加强安全性，为票据设置了一个 32 比特的生命周期，最长时长为 7 天。票据生命加值是一个随机生成的 32 比特的数值。由于会话票据是加密传输， 而预共享秘钥是明文传输， 客户端可利用这个加值来混淆 PSK ID 的真实票据时长。票据( 图 8) 由服务器创建，其本身一个用于数据库查询的关键字或者是一串密文，只有服务器自身才能查询或解密 PSK ID 恢复之前的会话状态。包含四个字段， 密钥名字也即“预共享密钥”消息中的 PSK ID， 方便服务器根据 ID 快速地找到自己签发过的票据; 加密状态字段主要用来存储第一次握手的状态信息; MAC 值防止票据被攻击者篡改; IV 用作计算 MAC 值和加密状态的初始向量输入。文献［14］ 提供了票据的构成方案和安全性分析。
2.4.2 预共享密钥
“预共享密钥”扩展消息( 图 9) 用来发送 PSK 的ID 值。客户端给服务器端发送一个 IDs 序列， 服务器端从中选取一个 ID 返回给客户端， 如果没有合适的值，则发送一个警告消息。如果与“早期数据”消息一起发送，将同时开启 0-ＲTT 交互模式。
IDs( 客户端) : 客户端提供给服务器端进行选择的一列 ID 值。
ID( 服务器端) : 服务器端从客户端提供的 IDs 中选取的一个 ID 值。
混淆票据时长: 客户端收到会话票据的时间加上会话票据的票据生命加值字段。由于预共享密钥是明文传输，所以这一策略隐藏了真实的票据时长。
绑定值: 绑定值利用 HMAC 算法建立了一个 PSK和当前的握手消息的绑定。在服务器接收客户端 PSK认证之前，首先要验证这个绑定值。如果这个值不存在或者验证失败，服务器必须终止会话，这个认证过程主要是为了防止中间人攻击。握手消息从“客户端Hello 消息”开始到“预共享密钥的”ID 字段为止， 但不包含绑定值本身。例如: 客户端发送一个 Hello1 消
息， 绑定值的 HMAC 计算将只包含这个 Hello1 消息;如果客户端发送一个 Hello1 消息， 服务器回了一个“请求重新握手”消息， 客户端再发送一个 Hello2 消息， 绑定值的 HMAC 计算将包含: Hello1 + 请求重新握手 + Hello2。
2.5 0_RTT
模式：客户端在发送客户端hello等消息时，一并发送应用层数据。
目的：减少握手时间。
必须和PSK模式一起使用。0-ＲTT 数据由 PSK 导出的早期流密钥加密传输。0-ＲTT 的消息交互过程如图 10 所示。
这种模式没有完整版的 TLS 握手协议安全: 1) 0-ＲTT 数据不能保证前向安全， 因为是用 PSK 导出的早期流密钥加密; 2) 不能保证不受重放攻击， 除非服务器采取协议外的防范措施。因此， 各方针对 0-ＲTT 的讨论较为激烈。反对方认为: 1) 0-ＲTT 存在上述两个
威胁，影响协议的安全性; 2) 1-ＲTT 模式已经能满足要求，没必要引入隐患; 3) 协议的实现者不一定精通密码学知识，盲目相信标准文档的安全性，且为了追求效率使用 0-ＲTT， 忽略了需要采取协议外的安全策略这一需求。支持方则坚持: 1) 可以为了效率， 对安全
性做出适当让步， 且谷歌公司已经在使用这一方案且效果良好; 2) 不宜直接反对并废除这一机制， 应该给通信双方选择的权利; 3) 可以把 0-ＲTT 模式作为一个扩展文档，与TLS1． 3 标准文档区分， 需要使用的时候即可作为扩展包添加使用。

四  SSL/TLS攻击以及TLS1.3防御措施
主要从协议的两层结构和代码实现这三方面对近几年出现的攻击进行分类概述
4.1  针对握手层的攻击
1）降级攻击
包括针对协议版本和针对密码种可用加密方式的回滚攻击。
利用中间人攻击，冒充通信的一方，诱使另一方修改密码算法列表，将协议版本或加密算法降低到不安全但仍被双方支持
2）重协商攻击
原理：因为通信双方的身份不是和安
全信道绑定的， 因此攻击者伪装成客户端与服务器进
行握手; 建立了通信信道之后再将原客户端要发送的
握手信息接入这个安全信道中，完成再次握手， 而通信
双方并不知情。
3）防范措施
针对降级攻击
TLS1.3移除了不安全算法，并在服务器Hello 消息的随机数字段中内嵌一个降级攻击保护机制。
在握手结束消息中对整个握手协议消息流内容进行哈希计算出消息认证码，防止消息被中间人篡改。

针对重协商攻击：
TLS1.3移除了重协商功能

4.2 针对记录层攻击
1) Lucky Thirteen 攻击
其攻击原理是 HMAC 验证计算时， 去掉填充信息
之后消息的长度不同会导致计算时间上的区别。攻击
者对密文进行针对性的修改之后， 根据 HMAC 验证的
处理时间长短可以获取关于密文的信息。
2) POODLE 攻击
其攻击原理主要是利用 SSL3． 0 协议中 CBC 加密
算法零值填充无规律且填充字符的完整性在解密时不
能进行验证的缺陷。
3) BEAST 攻击
主要利用 CBC 加密模式的链式结构， 即除了第一
条记录之外，之后每条记录进行加密时的初始向量都
是前一条记录的最后一个加密块。攻击者通过某种方
式够获取密文一个块的信息，然后逐块破解一段密文。
4) 防御措施
TLS1． 3 采用的 AEAD 算法可以避免 Lucky Thirteen 攻击。TLS1． 3 不允许将版本回退到 SSL3． 0， 且将
密文分组链接 ( CBC) 加 密 模 式 更 换 为 计 数 器 模式
( CTＲ) ，避免了后两种攻击。

4.3代码实现方面的攻击

在实现 TLS 协议的时候， 应用程序接口设计得较差，且由于标准文档存在部分令人混淆的设置和选项，开发者通常会误用、误解相关参数和选项的使用以及返回值，造成程序实现错误。
1) Heartbleed 攻击
主要是程序员在调用 memcpy( ) 函数时没有对缓冲区边界进行检查而造成的信息泄露。
2) 防御措施
TLS1． 3 在附录 B 中增加了许多代码实现方面的注意事项， 如: 伪随机数生成器的选取， 握手协议某些字段需要留意的特殊取值， 如 何 预 防 计 时 攻 击 等。TLS1． 3 主要涉及协议标准的设计， 代码的实现主要还是依靠工程师，双方都需引起重视。比如，为 TLS 库提供模糊测试和敌手测试， 设计一个简洁稳定的错误汇
报机制等

4.3 其他攻击手段
1) 时间差分攻击
针对对称算法和非对称算法都有计时攻击。其本质是通 过 观 察 不 同 数 据 的 加 解 密 时 间 差 实现密钥破解。
2) 公钥证书验证缺失［15］
另一个常见的攻击来源是公钥证书及其信任链验证的缺失( 尤其是基于移动终端的 SSL /TTL 实现) 。
3) 防御措施
TLS1． 3 采用 AEAD 算法，该算法会对待加密的明文进行填充，隐藏真实数据长度，混淆了加解密过程与时间的关联性。此外，TLS1． 3 丰富了证书链表这一部分的说明。


5 发展趋势

TLS1． 3 目前一直处于更新状态， 还有许多工作未完成，专家学者正从多方面对协议的制定进行激烈的讨论: 小到算法的选取、参数长度的范围确定， 大到新机制的引入、协议安全性证明。
纵观当前讨论热点可总结出以下几个发展趋势:
1) 密码算法的选取、移除与更新; 2) 密码算法密钥的长度以及相关参数范围的设置( 最大值， 最小值) ; 3)0-ＲTT 和 PSK 模式的进一步优化; 4) TLS 协议扩展文件的更新; 5) 商讨、解决 TLS 1． 3 draft 文档中的 open issues; 6) 握手层协议安全性证明［16］ 以及安全性分析［17］ 这一方向的研究较难，但非常重要。
实际应用中，协议的安全与否主要由两个方面决定: 协议的设计与实现。目前针对协议设计的讨论众多，但代码实现的安全性部分的考虑欠缺。本文作者希望互联网工程任务组在制定新的标准的同时可以为协议的代码实现人员提供一份说明文档， 详尽说明协议实现过程中可能会遇到的问题。比如， 提供一份详细的消息状态图和协议应用程序编程接口。标注标准文档中安全性较弱的部分。除了对协议的结构的安全性分析与证明， 也希望相关学者以及互联网开发人员重视协议代码安全实现这一方面的工作。
